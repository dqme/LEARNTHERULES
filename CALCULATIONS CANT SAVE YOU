<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CALCULATION</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Theme Colors */
            --bg-color-center: #1a202c; /* Dark Blue/Gray */
            --bg-color-outer: #4c1d95; /* Deep Purple */
            --text-color: #ffffff; /* Sharp White */
            --accent-color: #63b3ed; /* Light Blue/Cyan for SVG elements */
            --glitch-color: #f56565; /* Red for glitches */
        }

        body {
            font-family: 'Inter', sans-serif;
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 1rem;
            /* Animated Vortex Background */
            background: radial-gradient(ellipse at center, var(--bg-color-center) 0%, var(--bg-color-outer) 100%);
            background-size: 200% 200%; /* Start larger */
            animation: vortexBackground 25s cubic-bezier(0.25, 0.1, 0.25, 1) infinite alternate;
            position: relative;
        }

        /* Background animation: simulates pulling inwards/focusing */
        @keyframes vortexBackground {
            0% { background-position: center center; background-size: 250% 250%; }
            100% { background-position: center center; background-size: 100% 100%; }
        }

        /* Description paragraph styling */
        .description-paragraph {
            font-weight: 700; /* Bold */
            color: var(--text-color);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            line-height: 1.6;
            letter-spacing: -0.025em; /* Slightly tighter tracking */
            position: relative; /* Ensure it's above potential pseudo elements if added later */
            z-index: 1;
            opacity: 0; /* Start hidden, fade in */
            animation: fadeInDesc 2s ease-out 0.5s forwards; /* Fade in after delay */
        }

        @keyframes fadeInDesc {
            to { opacity: 1; }
        }

        /* Visual element container */
        .visual-element {
            display: flex;
            flex-grow: 1;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 600px; /* Max width for the calculation visual */
            position: relative;
        }

        /* SVG container */
        #calculationSvg {
            width: 100%;
            height: 100%;
            min-height: 300px; /* Ensure space for visuals */
            overflow: visible; /* Allow elements to potentially go slightly outside */
        }

        /* Default styles for SVG elements generated by JS */
        #calculationSvg text {
            font-family: 'Inter', sans-serif;
            font-size: 10px; /* Small text fragments */
            font-weight: bold;
            fill: var(--accent-color);
            text-anchor: middle;
            opacity: 0; /* Start hidden */
            transition: opacity 0.5s ease-out; /* CSS handles fade-in */
        }
        #calculationSvg circle,
        #calculationSvg rect {
            fill: none;
            stroke: var(--accent-color);
            stroke-width: 1px;
            opacity: 0; /* Start hidden */
            transition: opacity 0.5s ease-out; /* CSS handles fade-in */
        }
        #calculationSvg line { /* Style for potential future lines */
            stroke: var(--accent-color);
            stroke-width: 0.5px;
            stroke-dasharray: 2 2; /* Dashed lines */
            opacity: 0; /* Start hidden */
            transition: opacity 0.5s ease-out;
        }

        /* Style for the final "result" element */
        #calculationSvg .result-dot {
            fill: #ffffff; /* Bright white */
            stroke: none;
            filter: drop-shadow(0 0 5px #ffffff) drop-shadow(0 0 10px #ffffff); /* Glow effect */
            opacity: 0;
            transition: opacity 1s ease-in-out;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .description-paragraph { font-size: 1rem; }
            #calculationSvg text { font-size: 8px; }
        }
        @media (max-width: 480px) {
            .description-paragraph { font-size: 0.9rem; }
             #calculationSvg text { font-size: 7px; }
        }
    </style>
</head>
<body>

    <div class="description-wrapper max-w-3xl text-center mb-8 px-4 mx-auto">
        <p id="descriptionText" class="description-paragraph text-lg md:text-xl">
            The world narrows to the glint of the knife, the girl's terrified gasp, the captor's sneer. Noise fades. Training protocols flash and discard – useless. Rule 1: Irrelevant. Rule 'Protect': Failing. His breath steadies, heartbeat turning to a cold, metronomic thud. Options cycle – each worse than the last. Until one clicks into place. A terrible, precise calculation.
        </p>
    </div>

    <div class="visual-element">
        <svg id="calculationSvg" viewBox="0 0 300 200" preserveAspectRatio="xMidYMid meet"></svg>
    </div>

    <script>
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.getElementById('calculationSvg');
        const viewBox = svg.viewBox.baseVal;

        let elements = [];
        let animationFrameId = null;
        let startTime = null;
        const animationDuration = 12000; // ms

        // --- Get CSS Variable Values ---
        // We need these for the glitch effect reset
        const computedStyle = getComputedStyle(document.documentElement);
        const accentColor = computedStyle.getPropertyValue('--accent-color').trim() || '#63b3ed';
        const glitchColor = computedStyle.getPropertyValue('--glitch-color').trim() || '#f56565';


        // --- Helper Functions ---
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        function createSvgElement(type) {
            const el = document.createElementNS(svgNS, type);
            // Check if svg element exists before appending
            if (svg) {
                 svg.appendChild(el);
            } else {
                console.error("SVG container not found!");
                return null; // Return null if svg container doesn't exist
            }
            return el;
        }

        // --- Element Creation Functions ---
        function addCalculationElement() {
            if (elements.length > 50) return;

            const type = Math.random() > 0.6 ? 'text' : (Math.random() > 0.5 ? 'circle' : 'rect');
            const x = random(viewBox.width * 0.1, viewBox.width * 0.9);
            const y = random(viewBox.height * 0.1, viewBox.height * 0.9);
            const maxLife = random(2000, 5000);

            let el;
            if (type === 'text') {
                el = createSvgElement('text');
                if (!el) return; // Stop if element creation failed
                const fragments = ["P(Success)=Low%", "Risk: High", "Rule_1->FAIL", "Option C?", "VAR_X", "T-minus?", "CALC...", "ERR:", "ALT_ROUTE?", "IMPOSSIBLE"];
                el.textContent = fragments[Math.floor(random(0, fragments.length))];
                el.setAttribute('x', x);
                el.setAttribute('y', y);
            } else if (type === 'circle') {
                el = createSvgElement('circle');
                 if (!el) return; // Stop if element creation failed
                el.setAttribute('cx', x);
                el.setAttribute('cy', y);
                el.setAttribute('r', random(3, 8));
            } else { // rect
                el = createSvgElement('rect');
                 if (!el) return; // Stop if element creation failed
                const size = random(5, 15);
                el.setAttribute('x', x - size / 2);
                el.setAttribute('y', y - size / 2);
                el.setAttribute('width', size);
                el.setAttribute('height', size);
            }

            // Set initial opacity directly - CSS transition will handle the fade-in
            // Use setTimeout to ensure the element is in the DOM before setting opacity for transition
            setTimeout(() => {
                 if (el) { // Check if el exists before setting style
                    el.style.opacity = random(0.5, 0.9);
                 }
            }, 10); // Small delay


            elements.push({
                el: el,
                type: type,
                x: x, y: y,
                vx: random(-0.2, 0.2),
                vy: random(-0.2, 0.2),
                life: maxLife,
                maxLife: maxLife
            });
        }

        // --- Animation Loop ---
        function calculationLoop(timestamp) {
             // Ensure svg exists before proceeding
            if (!svg) {
                console.error("SVG container missing in animation loop.");
                cancelAnimationFrame(animationFrameId); // Stop the loop if SVG is gone
                return;
            }

            if (!startTime) startTime = timestamp;
            const elapsed = timestamp - startTime;

            // --- Update existing elements ---
            elements = elements.filter(item => {
                 // Check if item and item.el exist before processing
                if (!item || !item.el) return false;

                // Update position
                item.x += item.vx;
                item.y += item.vy;

                // Keep within bounds
                if (item.x < 0 || item.x > viewBox.width) item.vx *= -1;
                if (item.y < 0 || item.y > viewBox.height) item.vy *= -1;

                // Update element attributes
                try { // Add try-catch for safety when setting attributes
                    if (item.type === 'text') {
                        item.el.setAttribute('x', item.x);
                        item.el.setAttribute('y', item.y);
                    } else if (item.type === 'circle') {
                        item.el.setAttribute('cx', item.x);
                        item.el.setAttribute('cy', item.y);
                    } else { // rect
                        const size = parseFloat(item.el.getAttribute('width'));
                        item.el.setAttribute('x', item.x - size / 2);
                        item.el.setAttribute('y', item.y - size / 2);
                    }
                } catch (e) {
                    console.error("Error setting SVG attribute:", e, item);
                    // Optionally remove problematic item here
                    // svg.removeChild(item.el); return false;
                }


                // Decrease life
                item.life -= 16; // ~60fps

                // Update opacity
                const opacity = Math.min(0.9, (item.life / item.maxLife) * 2);
                 // Check if el still exists before setting style
                if (item.el) {
                    item.el.style.opacity = opacity;
                }


                // Glitch effect
                if (Math.random() < 0.005) {
                     // Check if el still exists before setting style
                    if (item.el) {
                        item.el.style.fill = glitchColor;
                        item.el.style.stroke = glitchColor;

                        const tempX = item.x + random(-10, 10);
                        const tempY = item.y + random(-10, 10);
                        try { // Add try-catch
                            if (item.type === 'text') { item.el.setAttribute('x', tempX); item.el.setAttribute('y', tempY); }
                            else if (item.type === 'circle') { item.el.setAttribute('cx', tempX); item.el.setAttribute('cy', tempY); }
                            else { item.el.setAttribute('x', tempX - parseFloat(item.el.getAttribute('width'))/2); item.el.setAttribute('y', tempY - parseFloat(item.el.getAttribute('height'))/2); }
                        } catch (e) { console.error("Error during glitch move:", e, item); }


                        // Reset glitch style
                        setTimeout(() => {
                            // Check element still exists before resetting style
                            if (item.el && svg.contains(item.el)) {
                                item.el.style.fill = item.type === 'text' ? accentColor : 'none';
                                item.el.style.stroke = item.type !== 'text' ? accentColor : 'none';
                            }
                        }, 100);
                    }
                }


                // Remove element if life <= 0
                if (item.life <= 0) {
                    // Check if el exists and is still a child of svg before removing
                    if (item.el && svg.contains(item.el)) {
                         try { svg.removeChild(item.el); } catch (e) { console.error("Error removing child:", e, item.el); }
                    }
                    return false; // Remove from array
                }
                return true; // Keep in array
            });

            // --- Add new elements periodically ---
            if (elapsed < animationDuration && Math.random() < 0.1) { // Only add during active animation
                addCalculationElement();
            }

            // --- Continue or Stop Animation ---
            if (elapsed < animationDuration) {
                animationFrameId = requestAnimationFrame(calculationLoop);
            } else {
                // Animation finished
                 console.log("Calculation animation finished."); // Debug log
                // Clear remaining elements safely
                elements.forEach(item => {
                     if (item && item.el && svg.contains(item.el)) {
                         try { svg.removeChild(item.el); } catch (e) { console.error("Error removing child post-loop:", e, item.el); }
                     }
                });
                elements = [];
                showCalculationResult();
            }
        }

        // --- Show Final Result ---
        function showCalculationResult() {
             console.log("Showing calculation result."); // Debug log
            const resultDot = createSvgElement('circle');
             if (!resultDot) return; // Stop if element creation failed

            resultDot.setAttribute('cx', viewBox.width / 2);
            resultDot.setAttribute('cy', viewBox.height / 2);
            resultDot.setAttribute('r', 3);
            resultDot.classList.add('result-dot');

            // Fade in the result dot
            setTimeout(() => { // Use timeout for safety
                if (resultDot) { // Check again
                    resultDot.style.opacity = 1;
                }
            }, 10);
        }

        // --- Start the Animation ---
         // Ensure SVG container exists before starting
        if (svg && viewBox) {
            console.log("Starting calculation animation."); // Debug log
            animationFrameId = requestAnimationFrame(calculationLoop);
        } else {
            console.error("Could not start animation: SVG container or viewBox not found.");
        }

    </script>

</body>
</html>
